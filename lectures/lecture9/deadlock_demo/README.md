# Демонстрація взаємного блокування

Розглянемо класичну задачу з багатопотокового програмування:

За круглим столом сидить п'ять філософів, які не спілкуються один з одним.
Перед кожним стоїть одна тарілка спагеті, а також на столі лежить п'ять виделок,
по одній зліва і по одній справа від тарілки.

Кожен філософ в певний момент часу може або їсти, або думати.

Щоб поїсти дуже довгі макарони, філософу під час їжі потрібно мати дві виделки.

Коли філософ їсть, він бере дві виделки зі столу, коли поїв — кладе виделки на стіл і починає думати.
Через деякий час процес повторюється. 

Файл [./main.c](./main.c) містить не правильний розв'язок задачі. В ньому, виделки на столі представлені
як окремі м'ютекси. Для того щоб скористатись виделкою, філософ відкриває/очікує на відповідний м'ютекс.
Кожен філософ піднімає зі столу виделки в строгому порядку - спочатку ліву, потім праву.

При довготривалому виконанні програми, можна спостерігати взаємне блокування коли всі п'ять філософів
підняли зі столу по одній виделці та очікують другу.

## Вирішення проблеми

Одним з вирішенням проблеми є встановлення порядку за яким всі потоки звертаються до м'ютексів.
Наприклад, за їх номером від 0 до 4. Якщо потоку потрібно відкрити два м'ютекси M1 та M2, то
потік забов'язаний спочатку відкрити м'ютекс з найменшим індексом, а потім найбільшим.

За таким порядком, філософ 0 має спочатку взяти зі столу НЕ ліву виделку з номером 4,
а праву з номером 0.

Така стратегія унеможливлює ситуацію коли всі філософи піднімуть зі столу по одній виделці.

Недоліком цієї стратегії є те, що філософ 0 має найменші шанси поїсти і може зголодніти.

## Джерела та дотаткова інформація

[Wikipedia](https://uk.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0_%D1%84%D1%96%D0%BB%D0%BE%D1%81%D0%BE%D1%84%D1%96%D0%B2,_%D1%89%D0%BE_%D0%BE%D0%B1%D1%96%D0%B4%D0%B0%D1%8E%D1%82%D1%8C)